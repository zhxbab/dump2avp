#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
########################################################
# dump2avp_l is used for converting bochs dump files to avps
# it call dump2avp
########################################################
import sys, os , re, logging
from optparse import OptionParser
from operator import ne,eq
import gzip
from logging import info,debug,error,warning,critical
global reload_num
global smm
def adjust_data(size, data):
        new_data = ""
        for i in range(0,2*size,2):
            new_data = data[i:i+2] + new_data 
        return new_data


def parse_ic_file(ic_file):
    global reload_num
    global smm
    ic_initial_end = 0
    ic_result_start = 0
    ic_file_instr = []
    index = 0
    reload_num = 0
    #info(ic_file)
    with open(ic_file,"r") as fd:
        while True:
            line = fd.readline()
            if line:
                line = line.strip()
                if re.search(r'TRACER REPLAY',line): 
                    ic_initial_end = 1
                        
                if re.search(r'SHUTDOWN: tracer checkpoint',line): 
                    ic_result_start = 1
                    
                if re.search(r'\"SMI\"',line): 
                    smm = 1
                    info("This vector include SMM, don't check")
                    
                if (ic_result_start == 0) and (ic_initial_end == 1):
                    m = re.search(r'I:0x(\w+):0x(\w+):\"(.*)\";',line)
                    if m :
                        data = m.group(2)
                        addr = m.group(1)
                        instr = m.group(3)
                        if ne("TRACER DUMP",instr):
                            ic_file_instr.append({"addr":addr,"data":data,"instr":instr})
                            #info(ic_file_instr[index])
                            index +=1
                        else:
                            reload_num += 1
                    m = re.search(r'D:0x\w+:0x(\w+);',line)
                    if m:
                        ic_file_instr[-1]["data"] = m.group(1) + ic_file_instr[-1]["data"]
                        #info("data is %s"%(line))
            else:
                break
    return ic_file_instr
    
def parse_dump_file(dump_file):
    #info(dump_file)
    dump_result_start = 0
    dump_initial_end = 0
    dump_file_instr = []
    index = 0
    with open(dump_file,"r") as fd:
        while True:
            line = fd.readline()
            if line:
                line = line.strip()
                if re.search(r'initial end',line): 
                    dump_initial_end = 1
                        
                if re.search(r'result start',line): 
                    dump_result_start = 1
                        
                if (dump_result_start == 0) and (dump_initial_end == 1):
                    m = re.search(r'LEN (\d+) BYTES: (\w+) \[0x00(\w+)\]',line)
                    if m:
                        size = int(m.group(1),16)
                        data = adjust_data(size, m.group(2))
                        addr = m.group(3)
                        dump_file_instr.append({"addr":addr.upper(),"data":data.upper()})
                        #info(dump_file_instr[index])
                        index +=1
            else:
                break
    return dump_file_instr
        
def check_result(dump_file_instr,ic_file_instr,ic_file):
        global reload_num
        check_len = min(len(ic_file_instr),len(dump_file_instr))
        for i in range(0,check_len):
            index = i
            addr_flag = eq(ic_file_instr[i]["addr"],dump_file_instr[i]["addr"])
            data_flag = eq(ic_file_instr[i]["data"],dump_file_instr[i]["data"])
            if addr_flag and data_flag:
                pass
            else:
                info("Ic file %s occur a mismatch and exit!"%(ic_file))
                info("Instr %d, Addr %s, Data %s in ic file"%(i+10, ic_file_instr[i]["addr"],ic_file_instr[i]["data"]))
                info("Instr %d, Addr %s, Data %s in dump file"%(i+1,dump_file_instr[i]["addr"],dump_file_instr[i]["data"]))
                break
        info("Totally check %d instructions done and Tracer reload instr num is %d"%(index+1,reload_num-1))
            # there are 9 instrs for tracer reload
        
        

def check_dump_and_ic(dump_file,ic_file):
    global smm
    ic_file_instr = parse_ic_file(ic_file)
    if not smm:
        dump_file_instr = parse_dump_file(dump_file)
        check_result(dump_file_instr, ic_file_instr ,ic_file)
    
parser = OptionParser(usage="%prog arg1 arg2", version="%prog 0.1") #2016-01-15 version 0.2
parser.add_option("-d","--dir", dest="dump_dir", help="The dir of dump log files that generated by bochs", type = "str",default = "None")
parser.add_option("-f","--file", dest="dump_file", help="The dump log files that generated by bochs", type = "str")
parser.add_option("-s","--start", dest="sp", help="start point [default:0x0]", type = "int", default = 0x0)
parser.add_option("-n","--num", dest="num", help="dump log num [default:0xFFFFFFFF]", type = "int", default=0xFFFFFFFF)
parser.add_option("--check", dest="_check", help="check ic and dump log or not", action="store_true", default = False)
(option, additions) = parser.parse_args(sys.argv[1:])
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(filename)10s[line:%(lineno)6d] %(levelname)8s: %(message)s",
                        datefmt="%a, %d %b %Y %H:%M:%S", stream=sys.stdout)
path = os.path.abspath(".")
if not eq(option.dump_dir,"None"):
    file_list = os.listdir(option.dump_dir)
    index = 0
    for line in sorted(file_list):
        if not line.startswith("."):
            if not re.search(r'.avp',line) and not re.search(r'.ic',line) and not re.search(r'replay',line):
                if index >= option.sp and index < option.sp+option.num:
                    filepath = os.path.join(option.dump_dir,line)
                    dump_file = os.path.join(path,filepath)
                    info("convert file %s"%(dump_file))
                    os.system("dump2avp -f %s"%(filepath))
                    os.system("replay_check_list -a %s.avp -g"%(filepath))
                    if option._check:
                        os.system("gzip -d %s"%(dump_file + ".ic.gz"))
                        ic_file = dump_file + ".ic"
                        check_dump_and_ic(dump_file,ic_file)
                        os.system("gzip %s"%(ic_file))
                    index+=1
else:
    dump_file = os.path.join(path,option.dump_file)
    info("convert file %s"%(dump_file))
    os.system("dump2avp -f %s"%(option.dump_file))
    os.system("replay_check_list -a %s.avp -g"%(option.dump_file))
    if option._check:
        os.system("gzip -d %s"%(dump_file + ".ic.gz"))
        ic_file = dump_file + ".ic"
        check_dump_and_ic(dump_file,ic_file)
        os.system("gzip %s"%(ic_file))